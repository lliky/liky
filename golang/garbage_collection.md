date: 2024-03-20

go version: go1.21.6

# 垃圾回收原理

## 1 垃圾回收算法

### 1.1 标记-清扫

标记-清扫（Mark-Sweep）算法，两个主要阶段：

1. 标记：扫描并标记当前活着的对象
2. 清扫：清扫没有被标记的垃圾对象

标记-清扫算法是一种间接的垃圾回收算法，它不直接查找垃圾对象，而是通过活着对象推断出垃圾对象。扫描一般从栈上的根对象开始，可以采用深度优先算法或广度优先算法进行扫描。

缺点：经过几次的标记-清扫之后，可能会产生内存碎片，如果这时需要分配大对象，会导致分配内存失败



### 1.2 标记-压缩

标记-压缩（Mark-Compact）的标记过程和标记-清扫算法类似，在压缩的阶段，需要扫描活着的对象并将其压缩到空闲的区域，使得整体空间更紧凑，从而解决内存碎片问题。

缺点：由于内存的位置是随机性的，会坏缓存的局部性，需要额外空间去标记对象移动的位置，还需要更新引用改对象的指针，增加了实现的复杂度。



### 1.3 半空间复制

半空间复制（Semispace Copy）是一种空间换时间的算法。只能使用一半的内存空间，保留另外一半的内存空间用于快速压缩内存。

* 分两片相等大小的空间，称为 fromspace 和 tospace
* 
* 每次只使用 fromspace 空间，以 GC 区分
* GC 时，不分阶段，扫描根对象就开始压缩，从 frompace 到  tospace
* GC 后，交换 fromspace 和 tospace，开始新的轮次

半空间复制的压缩性消除了内存碎片，同时，其压缩时间比标记-压缩更短。其缺点就是浪费空间。



### 1.4 引用计数

引用计数（Reference Counting）是简单识别垃圾对象的算法。

* 对象每被引用一次，计数器加 1
* 对象每被删除引用一次，计数器减 1
* GC 时，把计数器等于 0 的对象删除

缺点：无法解决循环引用或自身引用问题。



### 1.5 分代 GC

分代 GC 指将对象按照存活时间进行划分。其对象分为年轻代和老年代（甚至更多代），采用不同的 GC 策略进行分类和管理。分代 GC 算法前提是死去的对象都是新创建不久的，拥有更高的 GC 回收率。

没有必要去扫描旧的对象，加快垃圾回收速度，提高处理能力和吞吐量。

缺点：没有办法及时回收老对象，并且需要额外开销引用和区分新老对象，特别是很多代。





