date: 2024-02-01

# 1. 概念

## 1.1 进程与线程

进程是操作系统资源分配的基本单位，线程是处理器任务调度和执行的基本单元。

一个进程可以存在多个线程，这些线程可以共享进程的内存等资源。不同进程具有不同的内存地址。

## 1.2 线程上下文切换

为了平衡每个线程被 CPU 公平利用，操作系统会在适当时间通过 定时器中断、IO 设备中断、系统调用进行上下文切换。

CPU 需完成用户态与内核态间的切换。

在之后说的线程通常指的是内核级线程

## 1.3 线程与协程

和线程不同，协程的创建、销毁、调度 依赖 Go 运行时调度器，对内核透明。

从几个方面来说明他们之间的不同

### 1.3.1 调度方式

协程和线程依赖 运行时调度器，对象关系是: M:N ，多对多的关系


![](../image/go/gmp_1.png)

### 1.3.2 上下文切换

协程切换不经过操作系统用户态和内核态的切换

### 1.3.3 调度策略

线程调度是抢占式的

协程调度是协作式的，当完成任务的时候主动将执行权让给其他协程。若一个协程运行很长时间，Go 调度才会抢占。

### 1.3.4 栈的大小

线程的栈大小一般在创建时指定，默认大小 2M；协程默认为2kb，可以动态的扩容



# 2 gmp 模型 

gmp = goroutine + machine + processor，GMP 模型概况了线程与协程的关系，协程依托于线程，借助操作系统将线程调度到 CPU 执行，从而最终执行协程。

## 2.1 g

1. g 即 goroutine，是 golang 中对协程的抽象；
2. g 有自己的运行栈、状态、以及执行的任务函数（由 go func 指定）；
3. g 需要绑定 p 才能执行，在 g 的视角中，p 就是它的 cpu；



## 2.2 p

1. p 即 processor，是 golang 中的调度器；
2. p 是 gmp 中枢，实现 g 和 m 之间的动态有机结合；
3. 对 g 而言，p 是其 cpu，g 只有被 p 调度，才得以执行；
4. 对 m 而言，p 是其执行代理，为其提供必要信息的同时，隐藏了调度细节；
5. p 的数量决定了 g 最大并行数量，可由用户通过 GOMAXPROCS 进行设定；



## 2.3 m

1. m 即 machine，是 golang 中对线程的抽象；
2. m 不直接执行 g，而是先和 p 绑定，由其实现代理；
3. 借由 p 的存在，m 无需和 g 绑死，也无需记录 g 的状态信息，因此在 g 的生命周期中可实现跨 m 执行



## 2.4 gmp

![](../image/go/gmp_2.png)
