## 二分法





## master 公式

$$
T(N) = a * T(N/b) + O(N^d)
$$

解释：

* **T(N)**：自身函数，母问题
* **a**：子问题被调用的次数（函数里面的递归调用函数有几个）
* **N/b**：每次函数处理子问题数据的规模（每次处理都需要是一样的规模）。举例
  * 每次划分两份，那么数据规模就是 1/2*N,  N/b = N/2, 此时 b = 2
  * 每次划分为原数据规模的 N * (2/3)，N/b = N/(3/2), 此时 b = 3/2
  * 这次划分二分之一，下次划分三分之二，这样子就不满足该公式
* O(N^d)：d 是除去递归代码外其他运算的时间复杂度

### master 公式使用

确定了 a, b, d 之后，可以直接套用

* log(b,a) > d：递归的时间复杂度 O(N^log(b,a))
* log(b,a) = d：递归的时间复杂度 O(N^d * logN)
* log(b,a) < d：递归的时间复杂度 O(N^d)



## 递归

每个递归函数都有两部分：

* 基线条件（base case）：函数不在调用自己，避免形成无限循环
* 递归条件（recursive casa）：函数调用自己

```go
func countDown(i int) {
    if i < 0 {	// 基线条件
        return 
    }
    countDown(i-1)	// 递归条件
}
```

### 栈

函数调用过程中，如果在调用另一个函数，当前函数暂停并处于未完成状态。

栈先进后出。

所有函数调用都会进入调用栈

调用栈可能会很长，这将占用大量的内存，如何解决：

* 使用循环
* 尾递归（不是所有语言都支持）

#### 尾递归

尾调用是指一个函数里的最后一个动作是返回一个函数的调用结果的情形，即最后一步新调用的返回值直接被当前函数的返回结果。

[尾调用](https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8)

和常规递归的区别

* 常规递归，每次函数调用时需要记录当前函数上下文信息，会保存在栈空间中。每次递归都会新建一个栈帧。

  ```go
  func Fib1(n int) int {
  	if n <= 1 {
  		return n
  	}
  	return Fib(n-1) + Fib(n-2)
  }
  ```

  

* 尾递归是在递归过程中，只有一个栈帧不断被刷新。函数执行完成后直接返回结果，不进行任何操作。

  ```go
  func Fib2(n int, prev, next int) int {
  	if n == 0 {
  		return prev
  	}
  	n--
  	return Fib2(n, next, next+prev)
  }
  ```



## 前缀树



## 并查集

岛问题  leetcode 200

进阶：如何设计一个并行算法解决这个问题



## KMP

字符串 str1 和 str2 ，str1 是否包含 str2，如果包含返回 str2 在 str1 中开始的位置。

如何做到时间复杂度 O(N) 完成？

leetcode 28



## Manacher

字符串 str 中，最长回文子串的长度如何求解？

如何做到时间复杂度 O(N) 完成？



概念：

* 回文半径
* 回文直径
* 回文半径数组
* 最右回文右边界 R 和 中心点 C



1. 中心点没有在 R 边界里，暴力扩

2. 中心在 R 内

   1. i’ 在 L...R 里，不扩, 半径就是 i' 的半径 

   2. i' 回文区域有部分跑到 L... R 外面 , 不扩，半径就是 i ~ R 

      abcdedcbakabcdedcft

   3. i' 区域刚好和 L 压线，暴力扩

      abcdcbakskabcdcba?





## 滑动窗口

双端队列

leetcode 239



## 单调栈

在数组中想找到一个数，左边和右边比这个数小、且离这个数最近的位置



leetcode 739

leetcode 42

定义：数组中累积和与最小值的乘积，假设叫指标 A。

题目一：给定一个正数数组，请返回子数组中，指标 A 最大的值。

leetcode 1856



## 树型DP套路

树型 DP 套路使用前提：

如果题目求解目标是 S 规则，则求解流程可以定成以每个节点为头节点的子树在 S 规则下的每一个答案，并且最终答案一定在其中

第一步：

以某个节点 X 为头节点的子树中，分析答案有哪些可能性，并且这种分析是以 X 的左子树、X 的右子树和 X 整棵树的角度来考虑可能性的。

第二步：

根据第一步的可能性分析，列出所有需要的信息

第三步：

合并第一步信息，对左树和右树提出同样的要求，并写出信息结构

第四步：

设计递归函数，递归函数是处理以 X 为头节点的情况下的答案。

包括设计递归的 basecase ，默认直接得到左树和右树的所有信息，以及把可能性做整合，并且要返回第三步的信息结构这四个小步骤。



### 题目一：二叉树节点间的最大距离问题

leetcode 543

### 题目二：派对的最大快乐值





## Morris 遍历

一种遍历二叉树的方式，并且时间复杂度 O(N)，额外空间复杂度 O(1)

通过利用原树中大量空闲指针的方式，达到节省空间的目的

### 细节：

假设来到当前节点 cur ，开始时 cur 来到头节点位置

1. 如果 cur 没有左孩子，cur 向右移动（cur = cur.Right）
2. 如果 cur 有左孩子，找到左子树上最右的节点 mostRight:
   * 如果 mostRight 的右指针指向空，让其指向 cur，然后 cur 向左移动（cur = cur.Left）。
   * 如果 mostRight 的右指针指向 cur，让其指向 null，然后 cur 向右移动（cur = cur.Right）。
3. cur 为空时遍历停止

有左树的可以来到两次
