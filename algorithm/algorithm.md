## 二分法





## master 公式

$$
T(N) = a * T(N/b) + O(N^d)
$$

解释：

* **T(N)**：自身函数，母问题
* **a**：子问题被调用的次数（函数里面的递归调用函数有几个）
* **N/b**：每次函数处理子问题数据的规模（每次处理都需要是一样的规模）。举例
  * 每次划分两份，那么数据规模就是 1/2*N,  N/b = N/2, 此时 b = 2
  * 每次划分为原数据规模的 N * (2/3)，N/b = N/(3/2), 此时 b = 3/2
  * 这次划分二分之一，下次划分三分之二，这样子就不满足该公式
* O(N^d)：d 是除去递归代码外其他运算的时间复杂度

### master 公式使用

确定了 a, b, d 之后，可以直接套用

* log(b,a) > d：递归的时间复杂度 O(N^log(b,a))
* log(b,a) = d：递归的时间复杂度 O(N^d * logN)
* log(b,a) < d：递归的时间复杂度 O(N^d)



## 递归

每个递归函数都有两部分：

* 基线条件（base case）：函数不在调用自己，避免形成无限循环
* 递归条件（recursive casa）：函数调用自己

```go
func countDown(i int) {
    if i < 0 {	// 基线条件
        return 
    }
    countDown(i-1)	// 递归条件
}
```

### 栈

函数调用过程中，如果在调用另一个函数，当前函数暂停并处于未完成状态。

栈先进后出。

所有函数调用都会进入调用栈

调用栈可能会很长，这将占用大量的内存，如何解决：

* 使用循环
* 尾递归（不是所有语言都支持）

#### 尾递归

尾调用是指一个函数里的最后一个动作是返回一个函数的调用结果的情形，即最后一步新调用的返回值直接被当前函数的返回结果。

[尾调用](https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8)

和常规递归的区别

* 常规递归，每次函数调用时需要记录当前函数上下文信息，会保存在栈空间中。每次递归都会新建一个栈帧。

  ```go
  func Fib1(n int) int {
  	if n <= 1 {
  		return n
  	}
  	return Fib(n-1) + Fib(n-2)
  }
  ```

  

* 尾递归是在递归过程中，只有一个栈帧不断被刷新。函数执行完成后直接返回结果，不进行任何操作。

  ```go
  func Fib2(n int, prev, next int) int {
  	if n == 0 {
  		return prev
  	}
  	n--
  	return Fib2(n, next, next+prev)
  }
  ```



## 前缀树



## 并查集

岛问题  leetcode 200

进阶：如何设计一个并行算法解决这个问题



## KMP

字符串 str1 和 str2 ，str1 是否包含 str2，如果包含返回 str2 在 str1 中开始的位置。

如何做到时间复杂度 O(N) 完成？

leetcode 28



## Manacher

字符串 str 中，最长回文子串的长度如何求解？

如何做到时间复杂度 O(N) 完成？



概念：

* 回文半径
* 回文直径
* 回文半径数组
* 最右回文右边界 R 和 中心点 C



1. 中心点没有在 R 边界里，暴力扩

2. 中心在 R 内

   1. i’ 在 L...R 里，不扩, 半径就是 i' 的半径 

   2. i' 回文区域有部分跑到 L... R 外面 , 不扩，半径就是 i ~ R 

      abcdedcbakabcdedcft

   3. i' 区域刚好和 L 压线，暴力扩

      abcdcbakskabcdcba?
